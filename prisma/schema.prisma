// Prisma Schema for SportsMatch Tokyo
// This is your Prisma schema file

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_URL") // Direct connection for migrations (bypasses pooler)
}

// Enum for attendance status
enum AttendanceStatus {
  REGISTERED  // User signed up but hasn't attended yet
  ATTENDED    // User attended the session
  NO_SHOW     // User didn't show up
}

// Enum for user language proficiency level
enum LanguageLevel {
  BEGINNER      // Just started learning
  INTERMEDIATE  // Can hold basic conversations
  ADVANCED      // Fluent but not native
  NATIVE        // Native speaker
}

// Enum for session vibe/atmosphere
enum SessionVibe {
  COMPETITIVE       // Serious, skill-focused play
  CASUAL            // Relaxed, social games
  ACADEMY           // Learning/teaching focused
  LANGUAGE_EXCHANGE // Practice language while playing
}

// Enum for report status
enum ReportStatus {
  PENDING   // Report submitted, awaiting review
  REVIEWED  // Report has been reviewed
  RESOLVED  // Action taken, report closed
  DISMISSED // Report dismissed (false positive)
}

// Enum for report reason
enum ReportReason {
  HARASSMENT      // Harassing or bullying behavior
  NO_SHOW         // Repeatedly not showing up
  SPAM            // Spam or promotional content
  CREEPY_BEHAVIOR // Inappropriate or creepy behavior
  FAKE_PROFILE    // Fake or misleading profile
  OTHER           // Other reason (specify in description)
}

// Enum for report entity type
enum ReportEntityType {
  USER    // Reporting a user
  SESSION // Reporting a session
}

// User model
model User {
  id                   String         @id @default(uuid())
  email                String         @unique
  username             String?        @unique
  display_name         String?
  bio                  String?        @db.Text
  avatar_url           String?
  location             String?        // City or area in Tokyo
  sport_preferences    String[]       // Array of preferred sports
  skill_levels         Json?          // JSON object of sport -> skill level
  notification_email   Boolean        @default(true)
  notification_push    Boolean        @default(true)
  language_preference  String         @default("en") // 'en' or 'ja'
  // Language exchange fields
  native_language      String?        // ISO 639-1 code (e.g., 'en', 'ja', 'ko')
  target_language      String?        // Language user wants to practice
  language_level       LanguageLevel? // Proficiency in target language
  email_verified       Boolean        @default(false)
  phone_number         String?        @unique
  phone_verified       Boolean        @default(false)
  is_admin             Boolean        @default(false)
  // Trust & verification
  is_verified_student  Boolean        @default(false) // University student verification
  is_banned            Boolean        @default(false) // User has been banned
  banned_at            DateTime?                      // When user was banned
  banned_reason        String?                        // Reason for ban
  // Reliability tracking
  no_show_count        Int            @default(0)    // Number of times user didn't show up
  reliability_score    Int            @default(100)  // 0-100 score (starts at 100%)
  created_at           DateTime       @default(now())
  updated_at           DateTime       @updatedAt

  // Relations
  created_sessions     Session[]      @relation("SessionCreator")
  user_sessions        UserSession[]
  sent_messages        Message[]      @relation("MessageSender")
  conversation_participants ConversationParticipant[]
  favorites            Favorite[]
  reviews              Review[]
  notifications        Notification[]
  reports_submitted    Report[]       @relation("ReportReporter")
  reports_received     Report[]       @relation("ReportedUser")
  waitlist_entries     Waitlist[]
  // Venue booking relations
  court_bookings       CourtBooking[]

  @@index([email])
  @@index([phone_number])
  @@index([username])
  @@index([reliability_score])
  @@index([is_banned])
}

// Sport Center model
model SportCenter {
  id          String    @id @default(uuid())
  name_en     String
  name_ja     String
  address_en  String
  address_ja  String
  station_en  String?
  station_ja  String?
  latitude    Float?
  longitude   Float?
  image_url   String?
  // Venue booking fields
  description_en String?  @db.Text
  description_ja String?  @db.Text
  phone       String?
  email       String?
  website     String?
  is_bookable Boolean   @default(false) // Whether venue supports online booking
  created_at  DateTime  @default(now())
  updated_at  DateTime  @updatedAt

  // Relations
  sessions    Session[]
  // Venue booking relations
  venue_partner     VenuePartner?
  courts            Court[]
  operating_hours   VenueOperatingHours[]
  amenities         VenueAmenity[]
  closures          VenueClosure[]
  commission_transactions CommissionTransaction[]

  @@index([name_en])
  @@index([name_ja])
  @@index([is_bookable])
}

// Session model
// DATABASE CONSTRAINTS:
// - Session_duration_positive: CHECK (duration_minutes > 0)
// - Session_max_participants_min: CHECK (max_participants IS NULL OR max_participants >= 2)
model Session {
  id                    String        @id @default(uuid())
  sport_center_id       String
  sport_type            String        // badminton, basketball, etc.
  skill_level           String        // beginner, intermediate, advanced
  date_time             DateTime
  duration_minutes      Int           // Must be > 0 (enforced by DB constraint)
  max_participants      Int?          // Must be >= 2 if set (enforced by DB constraint)
  description_en        String?       @db.Text
  description_ja        String?       @db.Text
  // Language exchange & vibe fields
  primary_language      String        @default("ja")    // Main language spoken (ISO 639-1)
  allow_english         Boolean       @default(false)   // English-friendly session
  vibe                  SessionVibe   @default(CASUAL)  // Session atmosphere
  created_by            String
  attendance_marked     Boolean       @default(false) // Whether host has marked attendance
  created_at            DateTime      @default(now())
  updated_at            DateTime      @updatedAt

  // Relations
  sport_center          SportCenter   @relation(fields: [sport_center_id], references: [id], onDelete: Cascade)
  creator               User          @relation("SessionCreator", fields: [created_by], references: [id], onDelete: Cascade)
  user_sessions         UserSession[]
  conversation          Conversation? @relation("SessionConversation")
  favorites             Favorite[]
  reviews               Review[]
  reports               Report[]      @relation("ReportedSession")
  waitlist              Waitlist[]
  // Venue booking relation
  court_booking         CourtBooking?

  @@index([sport_type])
  @@index([skill_level])
  @@index([date_time])
  @@index([sport_center_id])
  @@index([created_by])
  @@index([vibe])
  @@index([primary_language])
  @@index([allow_english])
  // Composite indexes for optimized query patterns
  @@index([date_time, sport_type])
  @@index([date_time, sport_center_id])
  @@index([sport_type, skill_level, date_time])
}

// UserSession model (attendance tracking)
// Tracks user registration for sessions and their attendance status
model UserSession {
  id          String            @id @default(uuid())
  user_id     String
  session_id  String
  status      AttendanceStatus  @default(REGISTERED)  // REGISTERED -> ATTENDED or NO_SHOW
  marked_at   DateTime          @default(now())       // When user registered
  attended_at DateTime?                               // When attendance was marked

  // Relations
  user        User      @relation(fields: [user_id], references: [id], onDelete: Cascade)
  session     Session   @relation(fields: [session_id], references: [id], onDelete: Cascade)

  @@unique([user_id, session_id])
  @@index([user_id])
  @@index([session_id])
  @@index([status])
}

// Conversation model
model Conversation {
  id              String                    @id @default(uuid())
  type            String                    @default("direct") // 'direct' or 'session'
  session_id      String?                   @unique
  name            String?                   // For group chats
  created_at      DateTime                  @default(now())
  updated_at      DateTime                  @updatedAt
  last_message_at DateTime?

  // Relations
  session         Session?                  @relation("SessionConversation", fields: [session_id], references: [id], onDelete: Cascade)
  participants    ConversationParticipant[]
  messages        Message[]

  @@index([session_id])
  @@index([last_message_at])
}

// ConversationParticipant model
model ConversationParticipant {
  id              String       @id @default(uuid())
  conversation_id String
  user_id         String
  joined_at       DateTime     @default(now())
  last_read_at    DateTime?

  // Relations
  conversation    Conversation @relation(fields: [conversation_id], references: [id], onDelete: Cascade)
  user            User         @relation(fields: [user_id], references: [id], onDelete: Cascade)

  @@unique([conversation_id, user_id])
  @@index([conversation_id])
  @@index([user_id])
}

// Message model
model Message {
  id              String       @id @default(uuid())
  conversation_id String
  sender_id       String
  content         String       @db.Text
  created_at      DateTime     @default(now())
  updated_at      DateTime     @updatedAt

  // Relations
  conversation    Conversation @relation(fields: [conversation_id], references: [id], onDelete: Cascade)
  sender          User         @relation("MessageSender", fields: [sender_id], references: [id], onDelete: Cascade)

  @@index([conversation_id])
  @@index([sender_id])
  @@index([created_at])
  // Composite index for paginated message retrieval
  @@index([conversation_id, created_at(sort: Desc)])
}

// Favorite model (bookmarked sessions)
model Favorite {
  id          String   @id @default(uuid())
  user_id     String
  session_id  String
  created_at  DateTime @default(now())

  // Relations
  user        User     @relation(fields: [user_id], references: [id], onDelete: Cascade)
  session     Session  @relation(fields: [session_id], references: [id], onDelete: Cascade)

  @@unique([user_id, session_id])
  @@index([user_id])
  @@index([session_id])
}

// Review model (session feedback)
// DATABASE CONSTRAINT: Review_rating_check CHECK (rating >= 1 AND rating <= 5)
// This ensures ratings are always valid at the database level
model Review {
  id          String   @id @default(uuid())
  user_id     String
  session_id  String
  rating      Int      // 1-5 stars (enforced by DB constraint: CHECK rating >= 1 AND rating <= 5)
  comment     String?  @db.Text
  created_at  DateTime @default(now())
  updated_at  DateTime @updatedAt

  // Relations
  user        User     @relation(fields: [user_id], references: [id], onDelete: Cascade)
  session     Session  @relation(fields: [session_id], references: [id], onDelete: Cascade)

  @@unique([user_id, session_id])  // One review per user per session
  @@index([user_id])
  @@index([session_id])
  @@index([rating])
}

// Notification model
model Notification {
  id          String   @id @default(uuid())
  user_id     String
  type        String   // 'session_reminder', 'new_message', 'session_update', 'new_review', etc.
  title       String
  message     String
  link        String?  // URL to navigate to when clicked
  read        Boolean  @default(false)
  created_at  DateTime @default(now())

  // Relations
  user        User     @relation(fields: [user_id], references: [id], onDelete: Cascade)

  @@index([user_id])
  @@index([read])
  @@index([created_at])
  // Composite index for efficient user notification queries
  @@index([user_id, read, created_at(sort: Desc)])
}

// Report model (user reports for trust & safety)
model Report {
  id               String           @id @default(uuid())
  reporter_id      String                              // User who submitted the report
  entity_type      ReportEntityType                    // USER or SESSION
  reported_user_id String?                             // If reporting a user
  session_id       String?                             // If reporting a session
  reason           ReportReason                        // Reason for report
  description      String?          @db.Text           // Additional details
  status           ReportStatus     @default(PENDING)  // Current status
  admin_notes      String?          @db.Text           // Notes from admin review
  resolved_by      String?                             // Admin who resolved
  resolved_at      DateTime?                           // When resolved
  created_at       DateTime         @default(now())
  updated_at       DateTime         @updatedAt

  // Relations
  reporter         User             @relation("ReportReporter", fields: [reporter_id], references: [id], onDelete: Cascade)
  reported_user    User?            @relation("ReportedUser", fields: [reported_user_id], references: [id], onDelete: SetNull)
  session          Session?         @relation("ReportedSession", fields: [session_id], references: [id], onDelete: SetNull)

  @@index([reporter_id])
  @@index([reported_user_id])
  @@index([session_id])
  @@index([status])
  @@index([created_at])
  @@index([entity_type])
}

// Waitlist model (for full sessions)
// When a session reaches max_participants, users can join the waitlist
model Waitlist {
  id          String   @id @default(uuid())
  session_id  String
  user_id     String
  position    Int?     // Optional: explicit position in waitlist
  notified    Boolean  @default(false) // Whether user was notified of spot opening
  notified_at DateTime?                // When notification was sent
  created_at  DateTime @default(now())

  // Relations
  session     Session  @relation(fields: [session_id], references: [id], onDelete: Cascade)
  user        User     @relation(fields: [user_id], references: [id], onDelete: Cascade)

  @@unique([session_id, user_id]) // User can only be on waitlist once per session
  @@index([session_id])
  @@index([user_id])
  @@index([created_at])           // For ordering waitlist by join time
}

// ==========================================
// VENUE BOOKING SYSTEM
// ==========================================

// Enum for booking status
enum BookingStatus {
  PENDING      // Awaiting confirmation
  CONFIRMED    // Booking confirmed
  CANCELLED    // Cancelled by user or venue
  COMPLETED    // Booking completed
  NO_SHOW      // User didn't show up
}

// Enum for payment status
enum PaymentStatus {
  PENDING      // Payment not yet received
  PAID         // Payment completed
  REFUNDED     // Payment refunded
  FAILED       // Payment failed
}

// Enum for venue partner status
enum VenuePartnerStatus {
  PENDING      // Application pending review
  APPROVED     // Approved partner
  SUSPENDED    // Temporarily suspended
  REJECTED     // Application rejected
}

// Venue Partner model (extends SportCenter for booking capabilities)
model VenuePartner {
  id                String              @id @default(uuid())
  sport_center_id   String              @unique
  // Business details
  business_name     String
  business_email    String
  business_phone    String
  contact_person    String
  // Partner status
  status            VenuePartnerStatus  @default(PENDING)
  commission_rate   Float               @default(0.10) // 10% default commission
  // Bank/payment details (for payouts)
  bank_name         String?
  bank_account      String?
  bank_branch       String?
  // Terms acceptance
  terms_accepted    Boolean             @default(false)
  terms_accepted_at DateTime?
  // Timestamps
  approved_at       DateTime?
  created_at        DateTime            @default(now())
  updated_at        DateTime            @updatedAt

  // Relations
  sport_center      SportCenter         @relation(fields: [sport_center_id], references: [id], onDelete: Cascade)

  @@index([status])
  @@index([business_email])
}

// Court model (individual bookable units within a venue)
model Court {
  id              String       @id @default(uuid())
  sport_center_id String
  name_en         String       // "Court 1", "Field A", etc.
  name_ja         String
  sport_type      String       // badminton, basketball, tennis, etc.
  description_en  String?      @db.Text
  description_ja  String?      @db.Text
  // Pricing
  price_per_hour  Int          // Price in JPY
  price_per_30min Int?         // Optional 30-min pricing
  // Capacity
  max_players     Int          @default(4)
  min_players     Int          @default(2)
  // Features
  indoor          Boolean      @default(true)
  has_lighting    Boolean      @default(true)
  has_equipment   Boolean      @default(false) // Equipment rental available
  // Status
  is_active       Boolean      @default(true)
  // Timestamps
  created_at      DateTime     @default(now())
  updated_at      DateTime     @updatedAt

  // Relations
  sport_center    SportCenter  @relation(fields: [sport_center_id], references: [id], onDelete: Cascade)
  time_slots      CourtTimeSlot[]
  bookings        CourtBooking[]

  @@index([sport_center_id])
  @@index([sport_type])
  @@index([is_active])
  @@index([price_per_hour])
}

// Court Time Slot model (available booking slots)
model CourtTimeSlot {
  id          String   @id @default(uuid())
  court_id    String
  day_of_week Int      // 0 = Sunday, 6 = Saturday
  start_time  String   // "09:00" format
  end_time    String   // "10:00" format
  is_active   Boolean  @default(true)
  // Special pricing for this slot (overrides court price)
  price_override Int?

  // Relations
  court       Court    @relation(fields: [court_id], references: [id], onDelete: Cascade)

  @@unique([court_id, day_of_week, start_time])
  @@index([court_id])
  @@index([day_of_week])
  @@index([is_active])
}

// Court Booking model (actual bookings)
model CourtBooking {
  id              String        @id @default(uuid())
  court_id        String
  user_id         String
  session_id      String?       // Optional: link to sports session
  // Booking details
  booking_date    DateTime      @db.Date
  start_time      String        // "09:00" format
  end_time        String        // "10:00" format
  duration_minutes Int
  // Pricing
  subtotal        Int           // Base price in JPY
  commission      Int           // Platform commission in JPY
  total_amount    Int           // Total charged to user
  venue_payout    Int           // Amount to pay venue (total - commission)
  // Status
  status          BookingStatus @default(PENDING)
  payment_status  PaymentStatus @default(PENDING)
  // Payment details
  payment_intent_id String?     // Stripe payment intent ID
  paid_at           DateTime?
  // Cancellation
  cancelled_at      DateTime?
  cancellation_reason String?
  refund_amount     Int?
  // Notes
  user_notes        String?     @db.Text
  venue_notes       String?     @db.Text
  // Timestamps
  created_at      DateTime      @default(now())
  updated_at      DateTime      @updatedAt

  // Relations
  court           Court         @relation(fields: [court_id], references: [id], onDelete: Cascade)
  user            User          @relation(fields: [user_id], references: [id], onDelete: Cascade)
  session         Session?      @relation(fields: [session_id], references: [id], onDelete: SetNull)
  commission      CommissionTransaction?

  @@index([court_id])
  @@index([user_id])
  @@index([session_id])
  @@index([booking_date])
  @@index([status])
  @@index([payment_status])
  @@index([created_at])
  // Composite indexes
  @@index([court_id, booking_date, start_time])
  @@index([user_id, status])
}

// Venue Operating Hours model
model VenueOperatingHours {
  id              String      @id @default(uuid())
  sport_center_id String
  day_of_week     Int         // 0 = Sunday, 6 = Saturday
  open_time       String      // "09:00" format
  close_time      String      // "22:00" format
  is_closed       Boolean     @default(false) // Closed on this day

  // Relations
  sport_center    SportCenter @relation(fields: [sport_center_id], references: [id], onDelete: Cascade)

  @@unique([sport_center_id, day_of_week])
  @@index([sport_center_id])
}

// Venue Amenity model
model VenueAmenity {
  id              String      @id @default(uuid())
  sport_center_id String
  name_en         String      // "Parking", "Locker Room", etc.
  name_ja         String
  icon            String?     // Icon identifier
  is_free         Boolean     @default(true)
  price           Int?        // Price if not free

  // Relations
  sport_center    SportCenter @relation(fields: [sport_center_id], references: [id], onDelete: Cascade)

  @@index([sport_center_id])
}

// Venue Holiday/Closure model
model VenueClosure {
  id              String      @id @default(uuid())
  sport_center_id String
  date            DateTime    @db.Date
  reason_en       String?
  reason_ja       String?
  is_full_day     Boolean     @default(true)
  start_time      String?     // If partial closure
  end_time        String?

  // Relations
  sport_center    SportCenter @relation(fields: [sport_center_id], references: [id], onDelete: Cascade)

  @@unique([sport_center_id, date])
  @@index([sport_center_id])
  @@index([date])
}

// Commission Transaction model (for tracking payouts)
model CommissionTransaction {
  id              String      @id @default(uuid())
  booking_id      String      @unique
  sport_center_id String
  // Amounts
  booking_amount  Int         // Total booking amount
  commission_rate Float       // Rate at time of booking
  commission_amount Int       // Platform commission
  venue_amount    Int         // Amount owed to venue
  // Payout status
  payout_status   PaymentStatus @default(PENDING)
  payout_date     DateTime?
  payout_reference String?    // Bank transfer reference
  // Timestamps
  created_at      DateTime    @default(now())
  updated_at      DateTime    @updatedAt

  // Relations
  booking         CourtBooking @relation(fields: [booking_id], references: [id], onDelete: Cascade)
  sport_center    SportCenter  @relation(fields: [sport_center_id], references: [id], onDelete: Cascade)

  @@index([sport_center_id])
  @@index([payout_status])
  @@index([created_at])
}
